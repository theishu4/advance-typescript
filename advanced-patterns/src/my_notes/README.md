# 3. Advanced Patterns

## 1. Branded Types

1. What is a Branded type?
2. Form Validation with Branded Types
3. Using Branded Types as Entity Ids
4. Creating Reusable Validity Checks with Branded Types and Type Helpers
5. Creating Validation Boundaries with Branded Types
6. Using Index Signatures with Branded Types

## 2. Globals

7. TypeScript s Global Scope
8. üíé Add Functionality to Existing Global Interfaces
9. Add Types to Properties of Global Namespaced Interfaces
10. Collocating Types for Global Interfaces

## 3. Type Predicates Assertion Function

11. Filtering with Type Predicates
12. Checking Types with Assertion Functions
13. üíé Avoiding TypeScript s Most Confusing Error
14. Combining Type Predicates with Generics
15. Combining Brands and Type Predicates
16. Combining Brands with Assertion Functions

## 4. Classes

17. Classes as Types and Values
18. üíé‚ùì Dive into Classes with Type Predicates
19. Assertion Functions and Classes
20. Class Implementation Following the Builder Pattern Explanation
21. üëáCreate a Type Safe Map with the Builder Pattern
<!-- Go to -> src\04-classes\20-type-safe-map.solution.ts -->
22. Importance of default generic
23. Building Chainable Middleware with the Builder Pattern

## 5. External Libraries

24. Extract Types to Extend an External Library
25. Finding Proper Type Arguments and Generics with Lodash
26. Add Query Params to an Express Request
27. Create a Runtime and Type Safe Function with Generics and Zod
28. Override External Library Types

## 6. Identity Function

29. Identity Functions as an Alternative to the as const
30. Add Constraints to an Identity Function
31. Specifying Where Inference Should Not Happen
32. Find the Generic Flow of an Identity Function
33. Reverse Mapped Types

## 7. Challenges:

1. Merge Dynamic Objects with Global Objects
2. Narrowing with an Array
3. Create a Type Safe Request Handler with Zod and Express
4. Building a Dynamic Reducer

| Notes

# Difference between Interface and types

1. Interface support declaration merging but type not.
2. type supporting object remapping but interface not.
